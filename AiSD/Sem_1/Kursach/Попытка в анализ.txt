/*

F(0) = 0, F(1) = 2 F(n) = 2*F(n-2) + 6

//=================================================================================================================

n%2 = 0
n = 2k, G(k) = F(2k), G(0) = F(0) = 0, G(k) = 2G(k-1) + 6 = A2^k+6;
G_p(k) = 2G_p(k-1) + 6; C = 2C + 6 => C = -6; (G_p = C - константа во всех решениях, не зависимо от k)
G(k) = A2^(k)-6; G(0) = A2^0-6 = 0 => A = 6; G(k) = 6*2^k-6;
F(n) = 6*2^(n/2)-6

//=================================================================================================================

n%2 = 1
n = 2k+1, G(k) = F(2k+1), G(0) = F(1) = 2;
G(k) = 2G(k-1)+6 = A2^k+C; C=-6; G(1) = A2^0-6 = 2 => A = 8;
G(k) = 8*2^k-6
F(n) = 8*2^((n-1)/2)-6

//=================================================================================================================

F(n) = тэта(2^(n/2))

//=================================================================================================================

Q(0) = 0, Q(1) = 2, Q(2) = 6, Q(n) = Q(n-2) + F(n-2) + 9

//=================================================================================================================

n%2 = 0
n = 2k, L(k) = Q(2k), L(1) = 6
Q(2k) = Q(2k-2) + F(2k-2) + 9 = Q(2k-2)+9 + 6*2^((2k-2)/2)-6;
L(k) = L(k-1) + 6*2^(k-1)+3 = 6 + (6*2^(1)+3 + 6*2^(2)+3 + ... + 6*2^(k-1)+3) = 6+3(k-1)+6(2^(1)+2^(2)+ ... +2^(k-1)) = 6+3(k-1)+6*2(2^(k-1)-1) = 3+3k+6*2^(k)-12 = 6*2^(k)+3k-9;
Геом. прогрессия: S = b1(q^n-1)/(q-1), b1 = 2, q = 2, n = k;
Q(n) = 6*2^(n/2)+3*n/2-9

//=================================================================================================================

n%2 = 1
n = 2k + 1, L(k) = Q(2k + 1), L(0) = 2;
Q(2k+1) = Q(2k-1) + F(2k-1) + 9 = Q(2k-1) + 8*2^((2k-2)/2)-6 + 9 = Q(2k-1)+3 + 8*2^(k-1);
L(k) = L(k-1)+3 + 8*2^(k-1) = 2 + 3k + 8(2^(1-1)+k^(2-1)+...+2^k-1) = 8(2^k-1)+3k+3=8*2^k+3k-6;
Q(n) = 8*2^((n-1)/2)+3n-1)/2-6

//=================================================================================================================

Q(n) = тэта(2^(n/2))

*/


void autoSolve(const uint8_t& num, const uint8_t& from, const uint8_t& to, const bool& isFinal) {
    if (num == 0) return;
	// ...
    if (isFinal) {
        switch (num)
        {
        case 1:
		
		// Q(1) = 2
		
            moveAutoEndPair(from);
            break;
        case 2:
		
		// Q(2) = F(1) + 2*Q(1) = 6
		
            autoSolve(1, from, t1, false);
            autoSolve(1, from, to, isFinal);
            autoSolve(1, t1, to, isFinal);
            break;
        default:

		// Q(n) = Q(n-2) + F(n-2) + Q(1) + 3 * F(1) + 1 = Q(n - 2) + F(n - 2) + 9
		
            autoSolve(num - 2, from, t1, false); // + F(n - 2)
            t2 = vHanoys.size() - 1 - vHanoys[from][1].color % 2;
            t3 = vHanoys.size() - t2 + 1;
            autoSolve(1, from, t3, false); // + F(1)
            autoSolve(1, from, t2, false); // + F(1)
            autoSolve(1, t3, from, false); // + F(1)
            moveAutoOne(t2, t3); // + 1
            autoSolve(1, from, to, isFinal); // + Q(1)
            autoSolve(num - 2, t1, to, isFinal);  // + Q(n - 2)
            break;
        }
    }
    else
        switch (num)
        {
        case 1: 
		
		// F(1) = 2
		
            moveAutoPair(from, to);
            break;
        default: 
		
		// F(n) = 2*F(n-2) + 3*F(1) = 2*F(n-2) + 6
		
            autoSolve(num - 2, from, t1, isFinal); // + F(n-2)
            autoSolve(1, from, t2, isFinal); // + F(1)
            autoSolve(1, from, to, isFinal); // + F(1)
            autoSolve(1, t2, to, isFinal); // + F(1)
            autoSolve(num - 2, t1, to, isFinal); // + F(n - 2)
            break;
        }
}